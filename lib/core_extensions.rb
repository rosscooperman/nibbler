class << Time
  # Used for getting multifield attributes like those generated by a
  # select_datetime into a new Time object. For example if you have
  # following <tt>params={:meetup=>{:"time(1i)=>..."}}</tt> just do
  # following:
  #
  # <tt>Time.parse_from_attributes(params[:meetup], :time)</tt>
  def parse_from_attributes(attrs, field, method = :gm)
    send(method.to_s, *attrs.keys.sort.grep(/^#{field.to_s}\(.+\)$/).map{|k| attrs[k]}) rescue nil
  end
end

# # from Technoblog
# # http://tech.rufy.com/entry/81
class Object  
  def to_bool
    return false if self == 0
    self ? true : false
  end

  ##
  #   @person ? @person.name : nil
  # vs
  #   @person.try(:name)
  def try(method)
    send method if respond_to? method
  end
  
  alias_method :is_an?, :is_a?
end

class Float
  def to_int_or_float
    self.to_i == self ? self.to_i : self.to_f
  end

  def to_radians
    ( self / 360.0 ) * Math::PI * 2
  end
end

module Enumerable
  def uniq_by
    h = {}; inject([]) {|a,x| h[yield(x)] ||= a << x}
  end
end

class String
  def extract_digits
    self.gsub(/[^\d]/,'')
  end
end

class Hash

  # lets through the keys in the argument
  # >> {:one => 1, :two => 2, :three => 3}.pass(:one)
  # => {:one=>1}
  def pass(*keys)
    tmp = self.clone
    tmp.delete_if {|k,v| ! keys.include?(k) }
    tmp
  end

  def recursively_symbolize_keys
    tmp = {}

    for k, v in self
      tmp[k] = if v.respond_to? :recursively_symbolize_keys
        v.recursively_symbolize_keys
      else
        v
      end
    end

    tmp.symbolize_keys
  end
end

if RUBY_VERSION >= '1.9'
  OrderedHash = ::Hash
else
  class OrderedHash < Array #:nodoc:
    def []=(key, value)
      if pair = assoc(key)
        pair.pop
        pair << value
      else
        self << [key, value]
      end
    end

    def [](key)
      pair = assoc(key)
      pair ? pair.last : nil
    end

    def keys
      collect { |key, value| key }
    end

    def values
      collect { |key, value| value }
    end
  end
end

class Numeric
  def roundup(nearest=10)
    self % nearest == 0 ? self : self + nearest - (self % nearest)
  end
  def rounddown(nearest=10)
    self % nearest == 0 ? self : self - (self % nearest)
  end
end